<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Noah Kamara</title><description>Website of Noah Kamara</description><link>http://noahkamara.com</link><language>en</language><lastBuildDate>Wed, 9 Feb 2022 10:10:43 +0100</lastBuildDate><pubDate>Wed, 9 Feb 2022 10:10:43 +0100</pubDate><ttl>250</ttl><atom:link href="http://noahkamara.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">http://noahkamara.com/articles/example-post</guid><title>Example Article</title><description>This is an Example Post. Lorem ipsum dolor sit amet, prima labore utroque an vix, ea vix modus graeci malorum. No dicta congue aperiam qui. Ne cotidieque *deterruisset* ~~mediocritatem~~ eum. No nisl graece rationibus ius, oratio evertitur in eum.</description><link>http://noahkamara.com/articles/example-post</link><pubDate>Sun, 30 Jul 2023 21:47:00 +0200</pubDate><content:encoded><![CDATA[<p>Lorem ipsum dolor sit amet, prima labore utroque an vix, ea vix modus graeci malorum. No dicta congue aperiam qui. Ne cotidieque <em>deterruisset</em> <s>mediocritatem</s> eum. No nisl graece rationibus ius, oratio evertitur in eum.</p><h2>Lorem ipsum dolor sit amet</h2><p>Eam enim <code>code inline</code> oblique ei, nemore intellegat in usu. Lorem ipsum dolor sit amet, prima labore utroque an vix, ea vix modus graeci malorum. No dicta <strong>congue</strong> aperiam qui. Ne cotidieque deterruisset mediocritatem eum. No nisl graece rationibus ius, oratio evertitur in eum. Eam enim partem oblique ei, nemore <strong>intellegat in usu</strong>. Cum at verear sapientem, dolorem iudicabit ei qui. Suas vitae facilisis te est. Cum dico unum assum ne, est ei everti gloriatur honestatis, atqui reprimique id eos. Ius lorem tincidunt an, quaeque <code>print</code> uscipiantur ei has, no per vide utamur. <code>Foundation</code></p><pre><button type="button" class="copy-button onclick="copyCodeBlock('// Swift "Hello, World!" Program
print("Hello, World!", 123)
```'">copy</button><code><span class="comment">// Swift "Hello, World!" Program</span>

<span class="call">print</span>(<span class="string">"Hello, World!"</span>, <span class="number">123</span>)
</code></pre><p>Has ad viderer iracundia inciderint</p><p>Has ad viderer iracundia inciderint. Tation accusamus eum no, nec no euismod habemus. An nam malis laudem causae. Eu oporteat consequat vel. Appetere incorrupte mea at, nominati quaestio expetenda qui cu. Sensibus neglegentur sit ea, eu quodsi euripidis sea.</p><p>This is a caption</p><p>Has ad viderer iracundia inciderint. Tation accusamus eum no, nec no euismod habemus. An nam malis laudem causae. Eu oporteat consequat vel. Appetere incorrupte mea at, nominati quaestio expetenda qui cu. Sensibus neglegentur sit ea, eu quodsi euripidis sea.</p><h2><strong>Running Shell Commands</strong></h2><p>Running commands in shell is fairly simple:</p><p>We only need to create a <code>Process</code> and assign it a <code>launchPath</code> , which is simply the path to the script we want to launch. Additionally we can add command line arguments by assigning a list of them to <code>arguments</code> if we need to.</p><pre><button type="button" class="copy-button onclick="copyCodeBlock('// Create the Process
let task = Process()
// Assign a Launch Path & CLI Arguments
task.launchPath = "/usr/local/bin/script"
task.arguments = ["some", "cli", "arguments"]
```'">copy</button><code><span class="comment">// Create the Process</span>
<span class="keyword">let</span> task = <span class="type">Process</span>()

<span class="comment">// Assign a Launch Path &amp; CLI Arguments</span>
task.<span class="property">launchPath</span> = <span class="string">"/usr/local/bin/script"</span>
task.<span class="property">arguments</span> = [<span class="string">"some"</span>, <span class="string">"cli"</span>, <span class="string">"arguments"</span>]
</code></pre><p>I found out that Homebrew's launchPath is <code>/usr/local/bin/brew</code> by using the <code>which</code> command (<code>which brew</code>), which lists a commands launchPath. We want to install a formula so we need to user the <code>install</code> argument, followed by the formula we want to install: <code>install &lt;formula&gt;</code></p><pre><button type="button" class="copy-button onclick="copyCodeBlock('// Assign a Launch Path
task.launchPath = "/usr/local/bin/brew"
// Assign CLI Arguments
task.arguments = ["install", "python3"]
```'">copy</button><code><span class="comment">// Assign a Launch Path</span>
task.<span class="property">launchPath</span> = <span class="string">"/usr/local/bin/brew"</span>

<span class="comment">// Assign CLI Arguments</span>
task.<span class="property">arguments</span> = [<span class="string">"install"</span>, <span class="string">"python3"</span>]
</code></pre><p>Now we need to <code>launch</code> our process. This will start execution while the <code>waitUntilExit</code>-Method tells our program to wait until the code has terminated.</p><p>This waiting will be important for later :)</p><pre><button type="button" class="copy-button onclick="copyCodeBlock('// Launch the Process & tell it to wait until completion
task.launch()
task.waitUntilExit()
```'">copy</button><code><span class="comment">// Launch the Process &amp; tell it to wait until completion</span>
task.<span class="call">launch</span>()
task.<span class="call">waitUntilExit</span>()
</code></pre><h2><strong>Handling terminal output</strong></h2><p>Homebrew outputs information about the current installation step (e.g. Checksum verification, package installation) to the console.</p><p>We can retrieve that output by assigning a pipe to our Process. Pipes are one-way communications channels between related processes. In our case we want to establish communication between our application (Process I) and the shell commands we run (Process II).</p><pre><button type="button" class="copy-button onclick="copyCodeBlock('// Add a Pipe to the Process for output
let pipe = Pipe()
task.standardOutput = pipe // to capture standard output 
task.standardError  = pipe // to capture errors
```'">copy</button><code><span class="comment">// Add a Pipe to the Process for output</span>
<span class="keyword">let</span> pipe = <span class="type">Pipe</span>()
task.<span class="property">standardOutput</span> = pipe <span class="comment">// to capture standard output</span> 
task.<span class="property">standardError</span>  = pipe <span class="comment">// to capture errors</span>
</code></pre><p><strong>Now to the interesting bit: Actually getting the output</strong></p><p>Pipes work similar to files By assigning the pipe to the <code>standardOutput</code> and <code>standardError</code> we basically tell the Process to write output to it.</p><p>We can access the data by "reading" it from the pipe. That means:</p><ul><li>Retrieving the File Handle for reading <code>pipe.fileHandleForReading</code></li><li>Reading the entire file <code>fileHandler.readDataToEndOfFile()</code></li></ul><p>This is why the <code>waitUntilExit</code> is important. If we don't tell the Process to wait for the task to finish, the data we retrieve here might not contain the full output (only the first couple of lines) because thats the only output the task provided before reading the pipe.</p><pre><button type="button" class="copy-button onclick="copyCodeBlock('// Retrieving the File Handle
let fileHandler = pipe.fileHandleForReading
// Reading the Data to a variable
let data        = fileHandler.readDataToEndOfFile()
// Decoding the Data
let output = String(data: data, encoding: .utf8)
```'">copy</button><code><span class="comment">// Retrieving the File Handle</span>
<span class="keyword">let</span> fileHandler = pipe.<span class="property">fileHandleForReading</span>

<span class="comment">// Reading the Data to a variable</span>
<span class="keyword">let</span> data        = fileHandler.<span class="call">readDataToEndOfFile</span>()

<span class="comment">// Decoding the Data</span>
<span class="keyword">let</span> output = <span class="type">String</span>(data: data, encoding: .<span class="dotAccess">utf8</span>)
</code></pre><aside>
ðŸ’¡ The last step is to decode the binary data to something we can actually understand. If you want to know more about text encodings, I wrote an Article about it:  [Text Encoding for Dummies](https://www.notion.so/Text-Encoding-for-Dummies-a0f5ca6337454446b81c3aebe98accc8)

</aside><h3><strong>Implementing Continuous Output</strong></h3><p>Our initial implementation will return output but only once the command has finished executing, so we need to implement a way to notify the GUI of changes to the output.</p><p><strong>Ever heard of Notification Center?</strong></p><p>According to Apples documentation, it's a notification dispatch mechanism that enables the broadcast of information to registered observers. Implementing it is quite easy:</p><pre><button type="button" class="copy-button onclick="copyCodeBlock('// Retrieving the File Handle
let fileHandler = pipe.fileHandleForReading
// Reading the Data to a variable
let data = fileHandler.readDataToEndOfFile()
// Decoding the Data
let output = String(data: data, encoding: .utf8)
```'">copy</button><code><span class="comment">// Retrieving the File Handle</span>
<span class="keyword">let</span> fileHandler = pipe.<span class="property">fileHandleForReading</span>

<span class="comment">// Reading the Data to a variable</span>
<span class="keyword">let</span> data = fileHandler.<span class="call">readDataToEndOfFile</span>()

<span class="comment">// Decoding the Data</span>
<span class="keyword">let</span> output = <span class="type">String</span>(data: data, encoding: .<span class="dotAccess">utf8</span>)
</code></pre><p>First we need to tell the FileHandler to wait for data in the background and notify us whenever it's available. Then we create a reference to the default <code>NotificationCenter</code> as well as the <code>Observer</code> .</p><pre><button type="button" class="copy-button onclick="copyCodeBlock('// Tell the FileHandler to wait for data in the 
// Background
fileHandler.waitForDataInBackgroundAndNotify()
// Creating a reference to the default NC
let notificationCenter = NotificationCenter.default
// Creating the Observer
var dataObserver: NSObjectProtocol!
```'">copy</button><code><span class="comment">// Tell the FileHandler to wait for data in the 
// Background</span>
fileHandler.<span class="call">waitForDataInBackgroundAndNotify</span>()

<span class="comment">// Creating a reference to the default NC</span>
<span class="keyword">let</span> notificationCenter = <span class="type">NotificationCenter</span>.<span class="property">default</span>

<span class="comment">// Creating the Observer</span>
<span class="keyword">var</span> dataObserver: <span class="type">NSObjectProtocol</span>!
</code></pre><p>Now we're ready to add the Observer to the NotificationCenter. We tell it to observe notifications with the name of <code>NSFileHandleDataAvailable</code>. We also tell it that the object it should be observing is our <code>fileHandler</code> .</p><p>Inside the closure we add all we want to happen whenever the notification is received</p><pre><button type="button" class="copy-button onclick="copyCodeBlock('dataObserver = notificationCenter.addObserver(forName: NSNotification.Name.NSFileHandleDataAvailable, 
																							object: fileHandler, 
																							queue: nil) {  notification in
    let data = fileHandler.availableData
    guard data.count > 0 else {
        notificationCenter.removeObserver(dataObserver!)
        return
    }
    
    if var output = String(data: data, encoding: .utf8) {
        output = output.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)
        
//                if isVerbose {
//                    print(output)
//                }
        outputCallback(output)
    }
    outputHandler.waitForDataInBackgroundAndNotify()
}
```'">copy</button><code>dataObserver = notificationCenter.<span class="call">addObserver</span>(forName: <span class="type">NSNotification</span>.<span class="type">Name</span>.<span class="type">NSFileHandleDataAvailable</span>, 
																							object: fileHandler, 
																							queue: <span class="keyword">nil</span>) {  notification <span class="keyword">in
    let</span> data = fileHandler.<span class="property">availableData</span>
    <span class="keyword">guard</span> data.<span class="property">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> {
        notificationCenter.<span class="call">removeObserver</span>(dataObserver!)
        <span class="keyword">return</span>
    }
    
    <span class="keyword">if var</span> output = <span class="type">String</span>(data: data, encoding: .<span class="dotAccess">utf8</span>) {
        output = output.<span class="call">trimmingCharacters</span>(in: <span class="type">CharacterSet</span>.<span class="property">whitespacesAndNewlines</span>)
        
<span class="comment">//                if isVerbose {
//                    print(output)
//                }</span>
        <span class="call">outputCallback</span>(output)
    }
    outputHandler.<span class="call">waitForDataInBackgroundAndNotify</span>()
}
</code></pre><p>â†’ Possible later step: Parse Console Output to enhance GUI experience</p><p><strong>Superuser Mode</strong></p><p>Because installation of some packages requires an admin password, I need to somehow authenticate in another way (Entering the sudo password is only possible when running in a Terminal)</p><pre><button type="button" class="copy-button onclick="copyCodeBlock('sudo -S -v <<< 'password' 2> /dev/null
```'">copy</button><code>sudo -<span class="type">S</span> -v &lt;&lt;&lt; 'password' <span class="number">2</span>&gt; /dev/null
</code></pre><p>Some formulas could be quite large and network conditions bad so a download (might, very unlikely though) take longer than 5 minutes. A solution to this would be to download the cask prior to installing (we don't need a password for the download)</p><p>This workflow could be optimized by <em>researching</em> which installs require a sudo password (could be: casks in general, maybe brew query or api to find out?)</p><pre><button type="button" class="copy-button onclick="copyCodeBlock('# fetch an app (using avast as an example)
brew cask fetch avast
# renew sudo (expires in ~5min)
sudo -S -v <<< 'password' 2> /dev/null
# install an app
brew cask install avast
```'">copy</button><code># fetch an app (using avast <span class="keyword">as</span> an example)
brew cask fetch avast
# renew sudo (expires <span class="keyword">in</span> ~5min)
sudo -<span class="type">S</span> -v &lt;&lt;&lt; 'password' <span class="number">2</span>&gt; /dev/null
# install an app
brew cask install avast
</code></pre><ul><li>list<ul><li>list installed brews &amp; version</li><li>compare versions to latest â†’ show outdated brews</li><li>search</li><li>search for brews to install (could also just use json api tho)</li><li>install</li><li>update - update homebrew installation</li><li>upgrade - upgrade <cask>
- uninstall
- maybe troubleshooting commands built in?
    - find out what brew config & doctor do
    - check debug options for all commands - maybe debug / verbose mode?

```jsx
Example usage:
  brew search [TEXT|/REGEX/]
  brew info [FORMULA...]
  brew install FORMULA...
  brew update
  brew upgrade [FORMULA...]
  brew uninstall FORMULA...
  brew list [FORMULA...]

Troubleshooting:
  brew config
  brew doctor
  brew install --verbose --debug FORMULA

Contributing:
  brew create [URL [--no-fetch]]
  brew edit [FORMULA...]

Further help:
  brew commands
  brew help [COMMAND]
  man brew
  https://docs.brew.sh
```
</li></ul></li></ul>]]></content:encoded></item></channel></rss>